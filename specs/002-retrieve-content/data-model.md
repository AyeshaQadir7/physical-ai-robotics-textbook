# Data Model: Retrieve Embedded Book Content

**Feature**: Spec 2 - Retrieve embedded book content and validate RAG pipeline
**Date**: 2025-12-25

## Overview

The retrieval pipeline operates on data structures representing:
1. **Query** - Natural language question submitted for search
2. **QueryEmbedding** - Vector representation of query (1024-dimensional)
3. **SearchResult** - Retrieved chunk with metadata and similarity score
4. **RetrievalResponse** - Complete response containing results and metadata

All structures are designed to integrate seamlessly with the ingestion pipeline (Spec 1) and support future RAG chatbot development.

## Core Entities

### Query

**Purpose**: Represents a natural language search query

**Structure**:
```python
{
  "text": str,                # Natural language query (required)
  "query_id": str,            # Optional: Unique identifier for this query
  "timestamp": str,           # ISO 8601 timestamp when query was created
}
```

**Example**:
```json
{
  "text": "What is ROS2 and why is it used in robotics?",
  "query_id": "q_2025_12_25_001",
  "timestamp": "2025-12-25T21:30:00Z"
}
```

**Constraints**:
- `text` must be non-empty string (minimum 3 characters)
- `text` must be in English (embedding model assumes English)
- `text` maximum 1000 characters (reasonable for questions)

**Validation Rules**:
- Check length bounds (3-1000 characters)
- Reject empty or whitespace-only strings
- Log warnings for very short queries (<5 chars)

---

### QueryEmbedding

**Purpose**: Vector representation of a query, generated by Cohere

**Structure**:
```python
{
  "query_id": str,                    # Reference to source Query
  "embedding": List[float],           # 1024-dimensional vector
  "model": str,                       # "embed-english-v3.0" (Cohere model)
  "input_type": str,                  # "search_query" (Cohere input_type)
  "embedding_time_ms": float,         # Execution time for embedding
}
```

**Example**:
```json
{
  "query_id": "q_2025_12_25_001",
  "embedding": [0.123, 0.456, ..., 0.789],  # 1024 floats
  "model": "embed-english-v3.0",
  "input_type": "search_query",
  "embedding_time_ms": 234.5
}
```

**Constraints**:
- `embedding` must be exactly 1024 floats
- `embedding` values must be in range [-1.0, 1.0] (normalized vectors)
- `model` must match ingestion model (embed-english-v3.0)
- `input_type` must be "search_query" (Cohere-specific parameter for queries vs documents)

**Validation Rules**:
- Verify vector dimension (must be 1024)
- Verify all values are floats within valid range
- Log warning if embedding time exceeds 1000ms
- Compare model to ingestion config (must match for semantic consistency)

---

### SearchResult

**Purpose**: Retrieved content chunk with metadata and relevance score

**Structure**:
```python
{
  "chunk_id": str,                    # SHA256 hash ID (deterministic from content + URL)
  "chunk_text": str,                  # Actual text content of chunk
  "similarity_score": float,          # Cosine similarity [0.0 to 1.0], higher = more relevant
  "rank": int,                        # Position in result list (1-indexed)
  "metadata": {
    "source_url": str,                # URL where chunk was found
    "page_title": str,                # Title of the page
    "section_headers": List[str],     # Hierarchy of section headers
    "chunk_index": int,               # Index of chunk within page
    "tokens": int,                    # Approximate token count (512 target)
  }
}
```

**Example**:
```json
{
  "chunk_id": "a7f3e2b9c1d4e8f2...",
  "chunk_text": "ROS2 (Robot Operating System 2) is a flexible framework for writing robot software. It uses the DDS middleware for communication...",
  "similarity_score": 0.876,
  "rank": 1,
  "metadata": {
    "source_url": "https://physical-ai-robotics.vercel.app/docs/module-1-ros2/overview",
    "page_title": "Module 1: ROS2 Overview",
    "section_headers": ["Module 1: ROS2", "Introduction", "What is ROS2?"],
    "chunk_index": 0,
    "tokens": 512
  }
}
```

**Constraints**:
- `chunk_id` must be deterministic SHA256 hash (consistent with ingestion)
- `chunk_text` must be non-empty
- `similarity_score` must be float in range [0.0, 1.0]
- `rank` must be positive integer, sequential (1, 2, 3...)
- `source_url` must be valid HTTP(S) URL
- `page_title` must be non-empty
- `section_headers` must be non-empty list
- `chunk_index` must be non-negative integer

**Relationships**:
- Derived from `Chunk` entities created in Spec 1 ingestion
- References original page metadata (URL, title, headers)
- Matched against `QueryEmbedding` via Qdrant similarity search

**Validation Rules**:
- Verify chunk_id matches SHA256(url + text) from ingestion
- Verify all metadata fields present and non-empty
- Verify similarity_score is valid float
- Verify rank is sequential (no gaps in ranked results)
- Log warning if similarity_score is very low (<0.3, potentially irrelevant)

---

### RetrievalResponse

**Purpose**: Complete response from retrieval operation, ready for client consumption

**Structure**:
```python
{
  "status": str,                              # "success" or "error"
  "query": {
    "text": str,                              # Original query text
    "query_id": str,                          # Query identifier
  },
  "results": List[SearchResult],              # Ranked list of search results
  "total_results": int,                       # Number of results returned
  "requested_top_k": int,                     # Requested top-k parameter
  "execution_metrics": {
    "query_embedding_time_ms": float,         # Time to embed query
    "vector_search_time_ms": float,           # Time to search Qdrant
    "total_execution_time_ms": float,         # Total end-to-end time
    "embedding_model": str,                   # "embed-english-v3.0"
    "collection_name": str,                   # "textbook_embeddings"
  },
  "error": {                                  # Only present if status="error"
    "code": str,                              # Error code (e.g., "QDRANT_CONNECTION_FAILED")
    "message": str,                           # Human-readable error message
  }
}
```

**Example (Success)**:
```json
{
  "status": "success",
  "query": {
    "text": "What is ROS2?",
    "query_id": "q_2025_12_25_001"
  },
  "results": [
    {
      "chunk_id": "a7f3e2b9...",
      "chunk_text": "ROS2 (Robot Operating System 2)...",
      "similarity_score": 0.876,
      "rank": 1,
      "metadata": { ... }
    },
    {
      "chunk_id": "b8e4f1c2...",
      "chunk_text": "ROS2 provides a distributed middleware...",
      "similarity_score": 0.823,
      "rank": 2,
      "metadata": { ... }
    }
  ],
  "total_results": 2,
  "requested_top_k": 5,
  "execution_metrics": {
    "query_embedding_time_ms": 234.5,
    "vector_search_time_ms": 87.3,
    "total_execution_time_ms": 321.8,
    "embedding_model": "embed-english-v3.0",
    "collection_name": "textbook_embeddings"
  }
}
```

**Example (Error)**:
```json
{
  "status": "error",
  "query": {
    "text": "What is ROS2?",
    "query_id": "q_2025_12_25_001"
  },
  "results": [],
  "total_results": 0,
  "requested_top_k": 5,
  "execution_metrics": {
    "total_execution_time_ms": 45.2,
    "embedding_model": "embed-english-v3.0",
    "collection_name": "textbook_embeddings"
  },
  "error": {
    "code": "QDRANT_CONNECTION_FAILED",
    "message": "Failed to connect to Qdrant Cloud: Connection timeout after 30s"
  }
}
```

**Constraints**:
- `status` must be "success" or "error"
- If status="success": `results` must be non-empty list, `error` must be absent
- If status="error": `results` must be empty list, `error` must be present
- `total_results` must match length of `results` array
- `requested_top_k` must be positive integer (1-100)
- All timing fields must be non-negative floats
- `embedding_model` must match configuration

**Validation Rules**:
- Verify status consistency with results and error fields
- Verify total_results matches array length
- Verify all timing metrics are present and non-negative
- Verify results are ranked by similarity_score (descending)
- Log warning if execution time exceeds 2000ms

---

## Relationships

```
Query
  ↓ (embed with Cohere)
QueryEmbedding
  ↓ (search against collection)
[Qdrant Collection of 192+ vectors from Spec 1]
  ↓ (retrieve matching chunks)
SearchResult[]
  ↓ (package into response)
RetrievalResponse
```

**Data Flow**:
1. User submits natural language `Query`
2. System embeds query → `QueryEmbedding` (1024D vector)
3. System searches Qdrant collection with embedding
4. Qdrant returns matching chunks as `SearchResult[]`
5. System packages results into `RetrievalResponse`
6. Response returned to caller (test script or future RAG API)

---

## Type Definitions (Python)

```python
from typing import List, Dict, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Query:
    text: str
    query_id: str = ""
    timestamp: str = ""

@dataclass
class QueryEmbedding:
    query_id: str
    embedding: List[float]
    model: str = "embed-english-v3.0"
    input_type: str = "search_query"
    embedding_time_ms: float = 0.0

@dataclass
class SearchResult:
    chunk_id: str
    chunk_text: str
    similarity_score: float
    rank: int
    metadata: Dict[str, Any]

@dataclass
class RetrievalResponse:
    status: str  # "success" or "error"
    query: Dict[str, str]
    results: List[SearchResult]
    total_results: int
    requested_top_k: int
    execution_metrics: Dict[str, Any]
    error: Dict[str, str] = None
```

---

## Serialization

### JSON Format
All data structures serialized as JSON for logging, testing, and potential API integration:
- Timestamps in ISO 8601 format
- Similarity scores as floats (not percentages)
- Metadata preserves all fields from ingestion
- Error responses follow standard error structure

### Qdrant Native Format
SearchResults retrieved from Qdrant carry:
- `point.id` → `chunk_id` (deterministic UUID)
- `point.vector` → (not included in response, only metadata)
- `point.payload` → `metadata` (source_url, page_title, section_headers, etc.)

---

## Validation & Integrity

### Immutable References
- `chunk_id` must match original chunk from Spec 1 (prevents tampering)
- `source_url` must exactly match metadata from ingestion
- `similarity_score` generated by Qdrant (immutable at retrieval time)

### Consistency Rules
- All SearchResults from single RetrievalResponse must have same embedding model
- All SearchResults must be from same collection (textbook_embeddings)
- Ranks must be sequential (1, 2, 3...) with no gaps
- Similarity scores must be monotonically decreasing (rank 1 ≥ rank 2 ≥ rank 3...)

### Error States
- If Cohere API fails: RetrievalResponse.status = "error", results = []
- If Qdrant API fails: RetrievalResponse.status = "error", results = []
- If query embedding fails: RetrievalResponse.status = "error", query_embedding_time_ms = 0
- Partial failures (some results retrieved) are treated as success with lower result count
